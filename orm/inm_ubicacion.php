<?php

namespace gamboamartin\inmuebles\models;

use base\orm\_modelo_parent;
use gamboamartin\direccion_postal\models\dp_calle_pertenece;
use gamboamartin\direccion_postal\models\dp_colonia_postal;
use gamboamartin\errores\errores;
use gamboamartin\proceso\models\pr_proceso;
use PDO;
use stdClass;


class inm_ubicacion extends _inm_ubicaciones {

    private _modelo_parent $modelo_etapa;
    public bool $desde_prospecto = false;

    public function __construct(PDO $link)
    {
        $tabla = 'inm_ubicacion';
        $columnas = array($tabla=>false,'dp_colonia_postal'=>$tabla,
            'dp_cp'=>'dp_colonia_postal','dp_colonia'=>'dp_colonia_postal','dp_municipio'=>'dp_cp',
            'dp_estado'=>'dp_municipio','dp_pais'=>'dp_estado', 'inm_tipo_ubicacion'=>$tabla,
            'inm_status_ubicacion'=>$tabla,'com_agente'=>$tabla,'inm_estado_vivienda'=>$tabla,
            'inm_prototipo'=>$tabla, 'inm_complemento'=>$tabla);

        $campos_obligatorios = array('cuenta_predial','inm_tipo_ubicacion_id');

        $columnas_extra= array();
        $sql = "(CONCAT_WS(' ', inm_ubicacion.calle, inm_ubicacion.numero_exterior, 
        inm_ubicacion.numero_interior, dp_colonia.descripcion, dp_municipio.descripcion))";

        $columnas_extra['inm_ubicacion_ubicacion'] = $sql;

        $renombres= array();

        $atributos_criticos = array('manzana','lote','etapa','cuenta_predial',
            'inm_tipo_ubicacion_id','n_opiniones_valor','monto_opinion_promedio','costo');

        parent::__construct(link: $link, tabla: $tabla, campos_obligatorios: $campos_obligatorios,
            columnas: $columnas, columnas_extra: $columnas_extra, renombres: $renombres,
            atributos_criticos: $atributos_criticos);

        $this->NAMESPACE = __NAMESPACE__;
        $this->etiqueta = 'Ubicaciones';

        $this->modelo_etapa = new inm_ubicacion_etapa(link: $this->link);

    }

    /**
     * Inserta una ubicacion
     * @param array $keys_integra_ds Keys par ala generacion de la descripcion select
     * @return array|stdClass
     * @version 2.105.0
     */
    public function alta_bd(array $keys_integra_ds = array('codigo', 'descripcion')): array|stdClass
    {
        $valida = $this->valida_row(registro: $this->registro);
        if(errores::$error){
            return $this->error->error(mensaje: 'Error al valida $registro',data:  $valida);
        }
        $keys = array('cuenta_predial');
        $valida = $this->validacion->valida_existencia_keys(keys: $keys,registro:  $this->registro);
        if(errores::$error){
            return $this->error->error(mensaje: 'Error al validar registro',data:  $valida);
        }
        $keys = array('inm_tipo_ubicacion_id');
        $valida = $this->validacion->valida_ids(keys: $keys,registro:  $this->registro);
        if(errores::$error){
            return $this->error->error(mensaje: 'Error al validar registro',data:  $valida);
        }

        $r_alta_bd = parent::alta_bd(keys_integra_ds: $keys_integra_ds); // TODO: Change the autogenerated stub
        if(errores::$error){
            return $this->error->error(mensaje: 'Error al insertar ubicacion',data:  $r_alta_bd);
        }

        /*$r_alta_etapa = (new pr_proceso(link: $this->link))->inserta_etapa(adm_accion: __FUNCTION__, fecha: '',
            modelo: $this, modelo_etapa: $this->modelo_etapa, registro_id: $r_alta_bd->registro_id);
        if(errores::$error){
            return $this->error->error(mensaje: 'Error al insertar etapa', data: $r_alta_etapa);
        }*/

        $filtro_status_ubicacion['inm_status_ubicacion.descripcion'] = 'ALTA';
        $r_status_ubicacion = (new inm_status_ubicacion(link: $this->link))->filtro_and(
            filtro: $filtro_status_ubicacion);
        if(errores::$error){
            return $this->error->error(mensaje: 'Error al obtener status ubicacion', data: $r_status_ubicacion);
        }

        $modelo_inm_bitacora = new inm_bitacora_status_ubicacion(link: $this->link);
        $modelo_inm_bitacora->registro['inm_status_ubicacion_id'] = $r_status_ubicacion->registros[0]['inm_status_ubicacion_id'];
        $modelo_inm_bitacora->registro['inm_ubicacion_id'] = $r_alta_bd->registro_id;
        $modelo_inm_bitacora->registro['fecha_status'] =  date('Y-m-d\TH:i:s');
        $modelo_inm_bitacora->registro['observaciones'] =  'Status Inicial';
        $r_alta_status = $modelo_inm_bitacora->alta_bd();
        if(errores::$error){
            return $this->error->error(mensaje: 'Error al registrar elemnto de bitacora ubicacion', data: $r_alta_status);
        }

        if(isset($this->registro['com_agente_id'])) {
            $modelo_inm_rel_prospecto = new inm_rel_agente_ubicacion(link: $this->link);
            $modelo_inm_rel_prospecto->registro['com_agente_id'] = $this->registro['com_agente_id'];
            $modelo_inm_rel_prospecto->registro['inm_ubicacion_id'] = $r_alta_bd->registro_id;
            $modelo_inm_rel_prospecto->registro['fecha_asignacion'] = date('Y-m-d');
            $r_alta_rel = $modelo_inm_rel_prospecto->alta_bd();
            if (errores::$error) {
                return $this->error->error(mensaje: 'Error al registrar elemento de relacion agente', data: $r_alta_rel);
            }
        }

        $regenera = $this->regenera_datas(inm_ubicacion_id: $r_alta_bd->registro_puro->id);
        if(errores::$error){
            return $this->error->error(mensaje: 'Error al regenerar opinion de valor', data: $regenera);
        }

        return $r_alta_bd;
    }

    private function ajusta_conyuge(stdClass $datos, int $inm_ubicacion_id, PDO $link): array|stdClass
    {
        if(!$datos->existe) {
            $r_inm_rel_conyuge_ubicacion_bd = $this->inserta_conyuge(conyuge: $datos->row,
                inm_ubicacion_id: $inm_ubicacion_id,link: $link);
            if (errores::$error) {
                return $this->error->error(mensaje: 'Error al insertar conyuge', data: $r_inm_rel_conyuge_ubicacion_bd);
            }
            $data = $r_inm_rel_conyuge_ubicacion_bd;
        }
        else{
            $r_modifica_conyuge = $this->modifica_conyuge(
                conyuge: $datos->row, inm_ubicacion_id: $inm_ubicacion_id,link: $link);
            if (errores::$error) {
                return $this->error->error(mensaje: 'Error al modificar conyuge', data: $r_modifica_conyuge);
            }
            $data = $r_modifica_conyuge;
        }

        return $data;
    }

    /**
     * Asigna un precio de venta a un registro de ubicacion
     * @param int $indice Indice de arreglo de ubicaciones
     * @param stdClass $inm_comprador Datos de comprador
     * @param array $inm_ubicacion datos de ubicacion
     * @param array $inm_ubicaciones Conjunto de ubicaciones
     * @return array
     * @version 2.123.0
     */
    private function asigna_precio_venta(int $indice, stdClass $inm_comprador, array $inm_ubicacion,
                                         array $inm_ubicaciones): array
    {

        $valida = $this->valida_ids_precio(inm_comprador: $inm_comprador, inm_ubicacion: $inm_ubicacion);
        if(errores::$error){
            return $this->error->error(mensaje: 'Error al al validar entrada de datos',data: $valida);
        }
        if($indice < 0){
            return $this->error->error(mensaje: 'Error indice debe ser mayor o igual a 0',data: $indice);
        }

        $inm_precio_precio_venta = $this->inm_precio_venta(inm_comprador: $inm_comprador,
            inm_ubicacion: $inm_ubicacion);

        if(errores::$error){
            return $this->error->error(mensaje: 'Error al obtener inm_precio_precio_venta',
                data: $inm_precio_precio_venta);
        }
        $inm_ubicaciones[$indice]['inm_ubicacion_precio'] = round($inm_precio_precio_venta,2);
        return $inm_ubicaciones;
    }

    /**
     * Asigna los precios a un conjunto de ubicaciones
     * @param stdClass $inm_comprador Datos de comprador
     * @param stdClass $r_inm_ubicacion Resultado de ubicaciones
     * @return array
     * @version 2.123.0
     */
    private function asigna_precios(stdClass $inm_comprador,stdClass $r_inm_ubicacion): array
    {
        if(!isset($r_inm_ubicacion->registros)){
            return $this->error->error(mensaje: 'Error al r_inm_ubicacion->registros debe existir',
                data: $r_inm_ubicacion);
        }
        if(!is_array($r_inm_ubicacion->registros)){
            return $this->error->error(mensaje: 'Error al r_inm_ubicacion->registros debe ser un array',
                data: $r_inm_ubicacion);
        }

        $inm_ubicaciones = $r_inm_ubicacion->registros;

        foreach ($inm_ubicaciones as $indice=>$inm_ubicacion){
            if(!is_int($indice)){
                return $this->error->error(mensaje: 'Error indice debe ser un entero',data: $indice);
            }
            if(!is_array($inm_ubicacion)){
                return $this->error->error(mensaje: 'Error inm_ubicacion debe ser un array',data: $inm_ubicacion);
            }
            $valida = $this->valida_ids_precio(inm_comprador: $inm_comprador, inm_ubicacion: $inm_ubicacion);
            if(errores::$error){
                return $this->error->error(mensaje: 'Error al al validar entrada de datos',data: $valida);
            }
            if($indice < 0){
                return $this->error->error(mensaje: 'Error indice debe ser mayor o igual a 0',data: $indice);
            }
            $inm_ubicaciones = $this->asigna_precio_venta(indice: $indice,inm_comprador:  $inm_comprador,
                inm_ubicacion:  $inm_ubicacion,inm_ubicaciones:  $inm_ubicaciones);

            if(errores::$error){
                return $this->error->error(mensaje: 'Error al asignar precio de venta inm_ubicaciones',data: $inm_ubicaciones);
            }
        }
        return $inm_ubicaciones;
    }

    /**
     * Obtiene los datos necesarios para la integracion de precios
     * @param string $etapa Etapa a obtener
     * @param int $inm_comprador_id Identificador de comprador
     * @param bool $todas si todas obtiene todas las ubicaciones activas
     * @return array|stdClass
     * @version 2.125.0
     */
    private function data_ubicaciones(string $etapa, int $inm_comprador_id, bool $todas): array|stdClass
    {
        if($inm_comprador_id<=0){
            return $this->error->error(mensaje: 'Error inm_comprador_id debe ser mayor a 0',data: $inm_comprador_id);
        }
        $inm_comprador = (new inm_comprador(link: $this->link))->registro(registro_id: $inm_comprador_id,
            retorno_obj: true);
        if(errores::$error){
            return $this->error->error(mensaje: 'Error al obtener comprador',data: $inm_comprador);
        }

        $r_inm_ubicacion = $this->r_inm_ubicacion(etapa: $etapa,todas:  $todas);
        if (errores::$error) {
            return $this->error->error(mensaje: 'Error al obtener ubicaciones', data: $r_inm_ubicacion);
        }
        $data = new stdClass();
        $data->inm_comprador = $inm_comprador;
        $data->r_inm_ubicacion = $r_inm_ubicacion;
        return $data;
    }

    final public function dato(bool $existe, string $key_data): array|stdClass
    {
        $key_data = trim($key_data);
        if($key_data === ''){
            return $this->error->error(mensaje: 'Error key_data esta vacio',data:  $key_data);
        }

        $row = $this->init_post(key_data: $key_data);
        if(errores::$error){
            return $this->error->error(mensaje: 'Error al inicializar row',data:  $row);
        }

        $tiene_dato = $this->tiene_dato(row: $row);
        if(errores::$error){
            return $this->error->error(mensaje: 'Error al validar si tiene dato tiene_dato',data:  $tiene_dato);
        }
        $datos = new stdClass();
        $datos->existe = $existe;
        $datos->row = $row;
        $datos->tiene_dato = $tiene_dato;
        return $datos;
    }

    final public function datos_conyuge(PDO $link, int $inm_ubicacion_id): array|stdClass{
        $existe_conyuge = false;
        if($inm_ubicacion_id > 0) {
            $existe_conyuge = (new inm_ubicacion(link: $link))->existe_conyuge(inm_prospecto_id: $inm_ubicacion_id);
            if (errores::$error) {
                return $this->error->error(mensaje: 'Error al validar si existe conyuge', data: $existe_conyuge);
            }
        }

        $datos = $this->dato(existe: $existe_conyuge,key_data:  'conyuge');
        if(errores::$error){
            return $this->error->error(mensaje: 'Error al inicializar datos',data:  $datos);
        }

        return $datos;
    }

    /**
     * Genera la descripcion de una ubicacion
     * @param string $key_entidad_base_id Key de entidad base = inm_ubicacion_id
     * @param string $key_entidad_id Key de entidad proceso No aplica aqui
     * @param array $registro Registro en proceso
     * @param stdClass $dp_calle_pertenece Datos de calle
     * @return string|array
     * @version 2.106.0
     */
    final protected function descripcion(string $key_entidad_base_id, string $key_entidad_id, array $registro,
                                         stdClass $dp_calle_pertenece = new stdClass()): string|array
    {
        $keys = array('dp_pais_descripcion','dp_estado_descripcion','dp_municipio_descripcion',
            'dp_colonia_descripcion','dp_cp_descripcion');
        $valida = $this->validacion->valida_existencia_keys(keys: $keys,registro:  $dp_calle_pertenece);
        if(errores::$error){
            return $this->error->error(mensaje: 'Error al valida dp_calle_pertenece',data:  $valida);
        }

        $keys = array('calle','manzana','lote','numero_exterior','numero_interior');

        foreach ($keys as $key){
            if(!isset($registro[$key])){
                $registro[$key] = '';
            }
        }
        $descripcion = $dp_calle_pertenece->dp_pais_descripcion;
        $descripcion .= ' '.$dp_calle_pertenece->dp_estado_descripcion;
        $descripcion .= ' '.$dp_calle_pertenece->dp_municipio_descripcion;
        $descripcion .= ' '.$dp_calle_pertenece->dp_colonia_descripcion;
        $descripcion .= ' '.$dp_calle_pertenece->dp_cp_descripcion;
        $descripcion .= ' '.$registro['calle'];
        $descripcion .= ' '.$registro['manzana'].' '.$registro['lote'];
        $descripcion .= ' '.$registro['numero_exterior'].' '.$registro['numero_interior'];
        return trim($descripcion);
    }


    /**
     * Elimina una ubicacion junto con sus dependencias inm_ubicacion_etapa,inm_costo,inm_opinion_valor,inm_precio,
     * inm_rel_ubi_comp
     * @param int $id Id de ubicacion a eliminar
     * @return array|stdClass
     * @version 2.106.0
     */
    public function elimina_bd(int $id): array|stdClass
    {
        if($id <= 0){
            return $this->error->error(mensaje: 'Error id es menor a 0',data:  $id);
        }
        $filtro['inm_ubicacion.id'] = $id;
        $del = (new inm_ubicacion_etapa(link: $this->link))->elimina_con_filtro_and(filtro: $filtro);
        if(errores::$error){
            return $this->error->error(mensaje: 'Error al eliminar inm_ubicacion_etapa',data:  $del);
        }
        $del = (new inm_costo(link: $this->link))->elimina_con_filtro_and(filtro: $filtro);
        if(errores::$error){
            return $this->error->error(mensaje: 'Error al eliminar inm_costo',data:  $del);
        }
        $del = (new inm_opinion_valor(link: $this->link))->elimina_con_filtro_and(filtro: $filtro);
        if(errores::$error){
            return $this->error->error(mensaje: 'Error al eliminar inm_opinion_valor',data:  $del);
        }
        $del = (new inm_precio(link: $this->link))->elimina_con_filtro_and(filtro: $filtro);
        if(errores::$error){
            return $this->error->error(mensaje: 'Error al eliminar inm_precio',data:  $del);
        }
        $del = (new inm_rel_ubi_comp(link: $this->link))->elimina_con_filtro_and(filtro: $filtro);
        if(errores::$error){
            return $this->error->error(mensaje: 'Error al eliminar inm_rel_ubi_comp',data:  $del);
        }

        $r_elimina_bd = parent::elimina_bd(id: $id); // TODO: Change the autogenerated stub
        if(errores::$error){
            return $this->error->error(mensaje: 'Error al eliminar',data:  $r_elimina_bd);
        }


        return $r_elimina_bd;
    }

    final public function existe_conyuge(int $inm_prospecto_id): bool|array
    {
        if($inm_prospecto_id <=0){
            return $this->error->error(mensaje: 'Error inm_ubicacion_id es menor a 0',data:  $inm_prospecto_id);
        }
        $filtro = array();
        $filtro['inm_ubicacion.id'] = $inm_prospecto_id;

        $existe_conyuge = (new inm_rel_conyuge_ubicacion(link: $this->link))->existe(filtro: $filtro);
        if(errores::$error){
            return $this->error->error(mensaje: 'Error al validar si existe conyuge',data:  $existe_conyuge);
        }
        return $existe_conyuge;
    }

    /**
     * Obtiene el costo origen
     * @param int $inm_ubicacion_id Ubicacion id
     * @return array|float
     * @version 2.103.0
     */
    final public function get_costo(int $inm_ubicacion_id): float|array
    {
        if($inm_ubicacion_id<=0){
            return $this->error->error(mensaje: 'Error inm_ubicacion_id es menor a 0', data: $inm_ubicacion_id);
        }
        $filtro['inm_ubicacion.id'] = $inm_ubicacion_id;

        $campos['costo'] = 'inm_costo.monto';

        $r_inm_costo = (new inm_costo(link: $this->link))->suma(campos: $campos,filtro: $filtro);
        if(errores::$error){
            return $this->error->error(mensaje: 'Error al obtener costo', data: $r_inm_costo);
        }

        return round($r_inm_costo['costo'],2);

    }

    private function inserta_conyuge(array $conyuge, int $inm_ubicacion_id, PDO $link): array|stdClass
    {
        $keys = array('nombre','apellido_paterno','curp','rfc','dp_municipio_id','inm_nacionalidad_id',
            'inm_ocupacion_id','telefono_casa','telefono_celular','fecha_nacimiento');
        $valida = $this->validacion->valida_existencia_keys(keys: $keys,registro:  $conyuge);
        if(errores::$error){
            return $this->error->error(mensaje: 'Error al validar conyuge',data:  $valida);
        }
        $keys = array('dp_municipio_id','inm_nacionalidad_id', 'inm_ocupacion_id');
        $valida = $this->validacion->valida_ids(keys: $keys,registro:  $conyuge);
        if(errores::$error){
            return $this->error->error(mensaje: 'Error al validar conyuge',data:  $valida);
        }
        if($inm_ubicacion_id <= 0){
            return $this->error->error(mensaje: 'Error inm_ubicacion_id debe ser mayor a 0',data:  $inm_ubicacion_id);
        }

        $alta_conyuge = (new inm_conyuge(link: $link))->alta_registro(registro: $conyuge);
        if (errores::$error) {
            return $this->error->error(mensaje: 'Error al insertar conyuge', data: $alta_conyuge);
        }

        $inm_rel_conyuge_ubicacion_ins['inm_ubicacion_id'] = $inm_ubicacion_id;
        $inm_rel_conyuge_ubicacion_ins['inm_conyuge_id'] = $alta_conyuge->registro_id;

        $r_inm_rel_conyuge_ubicacion_bd = (new inm_rel_conyuge_ubicacion(link: $link))->alta_registro(
            registro: $inm_rel_conyuge_ubicacion_ins);
        if (errores::$error) {
            return $this->error->error(mensaje: 'Error al insertar conyuge', data: $r_inm_rel_conyuge_ubicacion_bd);
        }

        $data = new stdClass();
        $data->alta_conyuge = $alta_conyuge;
        $data->inm_rel_conyuge_ubicacion_ins = $inm_rel_conyuge_ubicacion_ins;
        $data->r_inm_rel_conyuge_ubicacion_bd = $r_inm_rel_conyuge_ubicacion_bd;

        return $data;
    }

    private function init_post(string $key_data): array
    {
        $key_data = trim($key_data);
        if($key_data === ''){
            return $this->error->error(mensaje: 'Error key_data esta vacio',data:  $key_data);
        }
        $data = array();
        if(isset($_POST[$key_data])){
            $data = $_POST[$key_data];
            if(is_string($data)){
                return $this->error->error(mensaje: 'Error POST '.$key_data.' debe ser un array',data:  $data);
            }
            unset($_POST[$key_data]);
        }
        return $data;
    }


    /**
     * Inicializa un registro para su alta
     * @param string $key_entidad_base_id Entidad base inm_ubicacion
     * @param string $key_entidad_id Entidad de avance
     * @param array $registro Registro en proceso
     * @return array
     * @version 2.107.0
     */
    final public function init_row(string $key_entidad_base_id,string $key_entidad_id, array $registro):array{

        $valida = $this->valida_row(registro: $registro);
        if(errores::$error){
            return $this->error->error(mensaje: 'Error al valida $registro',data:  $valida);
        }

        if(!isset($registro['manzana'])){
            $registro['manzana'] = '';
        }
        if(!isset($registro['lote'])){
            $registro['lote'] = '';
        }


        $dp_colonia_postal = (new dp_colonia_postal(link: $this->link))->registro(
            registro_id: $registro['dp_colonia_postal_id'],retorno_obj: true);
        if(errores::$error){
            return $this->error->error(mensaje: 'Error al obtener dp_colonia_postal',data:  $dp_colonia_postal);
        }


        if(!isset($registro['descripcion'])){

            $registro = $this->integra_descripcion(dp_colonia_postal: $dp_colonia_postal,registro:  $registro);
            if(errores::$error){
                return $this->error->error(mensaje: 'Error al integrar descripcion',data:  $registro);
            }

        }
        return $registro;
    }

    final public function inm_conyuge(bool $columnas_en_bruto, int $inm_ubicacion_id, PDO $link,
                                      bool $retorno_obj): array|stdClass
    {
        if($inm_ubicacion_id<=0){
            return $this->error->error(mensaje: 'Error inm_ubicacion_id debe ser mayor a 0', data:  $inm_ubicacion_id);
        }
        $filtro = array();
        $filtro['inm_ubicacion.id'] = $inm_ubicacion_id;
        $r_inm_rel_conyuge_ubicacion = (new inm_rel_conyuge_ubicacion(link: $link))->filtro_and(filtro: $filtro);
        if(errores::$error){
            return $this->error->error(mensaje: 'Error al obtener conyuge relacion',
                data:  $r_inm_rel_conyuge_ubicacion);
        }
        if($r_inm_rel_conyuge_ubicacion->n_registros === 0){
            return $this->error->error(mensaje: 'Error no existe relacion',data:  $r_inm_rel_conyuge_ubicacion);
        }
        if($r_inm_rel_conyuge_ubicacion->n_registros > 1){
            return $this->error->error(mensaje: 'Error de integridad',data:  $r_inm_rel_conyuge_ubicacion);
        }

        $inm_rel_conyuge_ubicacion = $r_inm_rel_conyuge_ubicacion->registros[0];

        $inm_conyuge = (new inm_conyuge(link: $link))->registro(
            registro_id: $inm_rel_conyuge_ubicacion['inm_conyuge_id'],columnas_en_bruto: $columnas_en_bruto,
            retorno_obj: $retorno_obj);
        if(errores::$error){
            return $this->error->error(mensaje: 'Error al obtener conyuge',data:  $inm_conyuge);
        }

        return $inm_conyuge;
    }

    /**
     * Obtiene el precio de venta de una ubicacion
     * @param stdClass $inm_comprador Comprador
     * @param array $inm_ubicacion Ubicacion
     * @return array|float|int
     * @version 2.118.0
     */
    private function inm_precio_venta(stdClass $inm_comprador, array $inm_ubicacion): float|array|int
    {
        $valida = $this->valida_ids_precio(inm_comprador: $inm_comprador, inm_ubicacion: $inm_ubicacion);
        if(errores::$error){
            return $this->error->error(mensaje: 'Error al al validar inm_comprador',data: $valida);
        }

        $inm_precio = (new inm_precio(link: $this->link))->precio(fecha: date('Y-m-d'),
            inm_ubicacion_id:  $inm_ubicacion['inm_ubicacion_id'],
            inm_institucion_hipotecaria_id:  $inm_comprador->inm_institucion_hipotecaria_id,valida_existe: false);

        if(errores::$error){
            return $this->error->error(mensaje: 'Error al obtener inm_precio',data: $inm_precio);
        }

        $inm_precio_precio_venta = 0.0;

        if(isset($inm_precio->inm_precio_precio_venta)){
            $inm_precio_precio_venta = round($inm_precio->inm_precio_precio_venta,2);
        }
        return $inm_precio_precio_venta;
    }

    /**
     * Integra una descripcion al dar de alta registro
     * @param stdClass $dp_colonia_postal Registro de domicilio
     * @param array $registro registro en proceso
     * @return array
     * @version 2.106.0
     */
    private function integra_descripcion(stdClass $dp_colonia_postal, array $registro): array
    {
        $keys = array('dp_pais_descripcion','dp_estado_descripcion','dp_municipio_descripcion',
            'dp_colonia_descripcion','dp_cp_descripcion');
        $valida = $this->validacion->valida_existencia_keys(keys: $keys,registro:  $dp_colonia_postal);
        if(errores::$error){
            return $this->error->error(mensaje: 'Error al valida dp_calle_pertenece',data:  $valida);
        }

        if(!isset($registro['numero_interior'])){
            $registro['numero_interior'] = '';
        }

        $descripcion = $this->descripcion(key_entidad_base_id: $this->key_id, key_entidad_id: '',
            registro: $registro, dp_calle_pertenece: $dp_colonia_postal);
        if(errores::$error){
            return $this->error->error(mensaje: 'Error al obtener descripcion',data:  $descripcion);
        }


        $registro['descripcion'] = $descripcion;
        return $registro;
    }

    /**
     * Modifica un registro de tipo ubicacion
     * @param array $registro Registro en proceso de modificacion
     * @param int $id Ide de ubicacion
     * @param bool $reactiva Si reactiva valida elementos de etapa
     * @param array $keys_integra_ds Keys para integracion de una descripcion select
     * @return array|stdClass
     * @version 2.108.0
     */
    public function modifica_bd(array $registro, int $id, bool $reactiva = false,
                                array $keys_integra_ds = array('codigo', 'descripcion')): array|stdClass
    {
        if($id<=0){
            return $this->error->error(mensaje: 'Error id debe ser mayor a 0',data: $registro);
        }

        $r_modifica_bd =  parent::modifica_bd(registro: $registro,id:  $id,
            reactiva:  $reactiva,keys_integra_ds:  $keys_integra_ds); // TODO: Change the autogenerated stub
        if(errores::$error){
            return $this->error->error(mensaje: 'Error al modificar inm_ubicacion', data: $r_modifica_bd);
        }

        if(isset($registro['com_agente_id'])) {
            $modelo_inm_rel_prospecto = new inm_rel_agente_ubicacion(link: $this->link);

            $filtro_rel_prosp['com_agente.id'] = $registro['com_agente_id'];
            $existe = $modelo_inm_rel_prospecto->existe(filtro: $filtro_rel_prosp);
            if (errores::$error) {
                return $this->error->error(mensaje: 'Error al registrar agente', data: $existe);
            }

            if(!$existe) {
                $modelo_inm_rel_prospecto->registro['com_agente_id'] = $registro['com_agente_id'];
                $modelo_inm_rel_prospecto->registro['inm_ubicacion_id'] = $id;
                $modelo_inm_rel_prospecto->registro['fecha_asignacion'] = date('Y-m-d');
                $r_alta_rel = $modelo_inm_rel_prospecto->alta_bd();
                if (errores::$error) {
                    return $this->error->error(mensaje: 'Error al registrar elemento de relacion agente', data: $r_alta_rel);
                }
            }
        }

        $regenera = $this->regenera_datas(inm_ubicacion_id: $r_modifica_bd->registro_actualizado->inm_ubicacion_id);
        if(errores::$error){
            return $this->error->error(mensaje: 'Error al regenerar opinion de valor', data: $regenera);
        }

        return $r_modifica_bd;
    }

    private function modifica_conyuge(array $conyuge, int $inm_ubicacion_id, PDO $link): array|stdClass
    {
        if($inm_ubicacion_id<=0){
            return $this->error->error(mensaje: 'Error inm__id debe ser mayor a 0', data:  $inm_ubicacion_id);
        }
        $inm_conyuge_previo = $this->inm_conyuge(columnas_en_bruto: true, inm_ubicacion_id: $inm_ubicacion_id,
            link: $link, retorno_obj: true);
        if (errores::$error) {
            return $this->error->error(mensaje: 'Error al obtener conyuge', data: $inm_conyuge_previo);
        }

        $inm_conyuge_id = $inm_conyuge_previo->id;

        $r_modifica_conyuge = (new inm_conyuge(link: $link))->modifica_bd(registro: $conyuge,id: $inm_conyuge_id);
        if (errores::$error) {
            return $this->error->error(mensaje: 'Error al modificar conyuge', data: $r_modifica_conyuge);
        }

        $data = new stdClass();
        $data->inm_conyuge_previo = $inm_conyuge_previo;
        $data->r_modifica_conyuge = $r_modifica_conyuge;

        return $data;
    }

    /**
     * Obtiene el monto de opiniones promedio
     * @param int $inm_ubicacion_id Ubicacion id
     * @return array|float
     * @version 2.97.0
     */
    final public function monto_opinion_promedio(int $inm_ubicacion_id): float|array
    {
        if($inm_ubicacion_id <= 0){
            return $this->error->error(mensaje: 'Error inm_ubicacion_id es menor a 0',data: $inm_ubicacion_id);
        }

        $n_opiniones = $this->n_opiniones_valor(inm_ubicacion_id: $inm_ubicacion_id);
        if(errores::$error){
            return $this->error->error(mensaje: 'Error al obtener n_opiniones',data: $n_opiniones);
        }

        $filtro['inm_ubicacion.id'] = $inm_ubicacion_id;

        $campos['total_montos'] = 'inm_opinion_valor.monto_resultado';
        $r_inm_opinion_valor = (new inm_opinion_valor(link: $this->link))->suma(campos: $campos,filtro: $filtro);
        if(errores::$error){
            return $this->error->error(mensaje: 'Error al obtener montos',data: $r_inm_opinion_valor);
        }

        $total_montos = 0;
        if($n_opiniones > 0){
            $total_montos = round($r_inm_opinion_valor['total_montos'],2) / $n_opiniones;
        }

        return round($total_montos ,2);
    }

    /**
     * Obtiene el numero de opiniones de valor generadas en una ubicacion
     * @param int $inm_ubicacion_id Ubicacion Id
     * @return array|int
     * @version 2.96.0
     */
    private function n_opiniones_valor(int $inm_ubicacion_id): int|array
    {
        if($inm_ubicacion_id <= 0){
            return $this->error->error(mensaje: 'Error inm_ubicacion_id es menor a 0',data: $inm_ubicacion_id);
        }

        $filtro['inm_ubicacion.id'] = $inm_ubicacion_id;
        $n_opiniones = (new inm_opinion_valor(link: $this->link))->cuenta(filtro: $filtro);
        if(errores::$error){
            return $this->error->error(mensaje: 'Error al obtener n_opiniones',data: $n_opiniones);
        }
        return $n_opiniones;
    }

    /**
     * Obtiene las opiniones de valor de una ubicacion
     * @param int $inm_ubicacion_id Identificador de ubicacion
     * @return array
     * @version 2.109.0
     */
    final public function opiniones_valor(int $inm_ubicacion_id): array
    {
        if($inm_ubicacion_id <= 0){
            return $this->error->error(mensaje: 'Error inm_ubicacion_id es menor a 0',data: $inm_ubicacion_id);
        }
        $filtro['inm_ubicacion.id'] = $inm_ubicacion_id;
        $r_inm_opinion_valor = (new inm_opinion_valor(link: $this->link))->filtro_and(filtro: $filtro);
        if(errores::$error){
            return $this->error->error(mensaje: 'Error al obtener opiniones',data: $r_inm_opinion_valor);
        }
        return $r_inm_opinion_valor->registros;
    }

    /**
     * Obtiene los datos de las ubicaciones
     * @param string $etapa Filtra por la etapa
     * @param bool $todas Integra todas las activas
     * @return array|stdClass
     * @version 2.124.0
     */
    private function r_inm_ubicacion(string $etapa, bool $todas): array|stdClass
    {


        if(!$todas) {
            $etapa = trim($etapa);
            if($etapa === ''){
                return $this->error->error(mensaje: 'Error etapa esta vacia', data: $etapa);
            }
            $filtro['inm_ubicacion.etapa'] = $etapa;
            $r_inm_ubicacion = $this->filtro_and(filtro: $filtro);
            if (errores::$error) {
                return $this->error->error(mensaje: 'Error al obtener ubicaciones', data: $r_inm_ubicacion);
            }
        }
        else{
            $r_inm_ubicacion_data = $this->registros_activos();
            if (errores::$error) {
                return $this->error->error(mensaje: 'Error al obtener ubicaciones', data: $r_inm_ubicacion_data);
            }

            $r_inm_ubicacion = new stdClass();
            $r_inm_ubicacion->registros = $r_inm_ubicacion_data;
        }
        return $r_inm_ubicacion;
    }

    /**
     * Regenera el costo de una ubicacion
     * @param int $inm_ubicacion_id Ubicacion en proceso
     * @return array|stdClass
     * @version 2.103.0
     */
    private function regenera_costo(int $inm_ubicacion_id): array|stdClass
    {
        if($inm_ubicacion_id<=0){
            return $this->error->error(mensaje: 'Error inm_ubicacion_id es menor a 0', data: $inm_ubicacion_id);
        }

        $costo = $this->get_costo(inm_ubicacion_id: $inm_ubicacion_id);
        if(errores::$error){
            return $this->error->error(mensaje: 'Error al obtener costo',data: $costo);
        }
        $inm_ubicacion_upd['costo'] = $costo;

        $upd = parent::modifica_bd(registro: $inm_ubicacion_upd,id:  $inm_ubicacion_id);
        if(errores::$error){
            return $this->error->error(mensaje: 'Error al actualizar n_opiniones',data: $upd);
        }
        return $upd;

    }

    /**
     * Regenera los datos de opiniones de valor
     * @param int $inm_ubicacion_id Ubicacion id
     * @return array|stdClass
     * @version 2.102.0
     */
    private function regenera_data_opinion(int $inm_ubicacion_id): array|stdClass
    {
        if($inm_ubicacion_id <= 0){
            return $this->error->error(mensaje: 'Error inm_ubicacion_id es menor a 0',data: $inm_ubicacion_id);
        }

        $n_opiniones = $this->n_opiniones_valor(inm_ubicacion_id: $inm_ubicacion_id);
        if(errores::$error){
            return $this->error->error(mensaje: 'Error al obtener n_opiniones',data: $n_opiniones);
        }
        $inm_ubicacion_upd['n_opiniones_valor'] = $n_opiniones;
        $promedio = $this->monto_opinion_promedio(inm_ubicacion_id: $inm_ubicacion_id);
        if(errores::$error){
            return $this->error->error(mensaje: 'Error al obtener promedio',data: $promedio);
        }
        $inm_ubicacion_upd['monto_opinion_promedio'] = $promedio;

        $upd = parent::modifica_bd(registro: $inm_ubicacion_upd,id:  $inm_ubicacion_id);
        if(errores::$error){
            return $this->error->error(mensaje: 'Error al actualizar n_opiniones',data: $upd);
        }
        return $upd;

    }

    /**
     * Regenera el costo y los valor promedio de opinion
     * @param int $inm_ubicacion_id Ubicacion en proceso
     * @return array|stdClass
     * @version 2.104.0
     */
    final public function regenera_datas(int $inm_ubicacion_id): array|stdClass
    {

        if($inm_ubicacion_id <= 0){
            return $this->error->error(mensaje: 'Error inm_ubicacion_id es menor a 0',data: $inm_ubicacion_id);
        }

        $regenera_op = $this->regenera_data_opinion(inm_ubicacion_id: $inm_ubicacion_id);
        if(errores::$error){
            return $this->error->error(mensaje: 'Error al regenerar opinion de valor', data: $regenera_op);
        }
        $regenera_costo = $this->regenera_costo(inm_ubicacion_id: $inm_ubicacion_id);
        if(errores::$error){
            return $this->error->error(mensaje: 'Error al regenerar costo', data: $regenera_costo);
        }
        $data = new stdClass();
        $data->regenera_op = $regenera_op;
        $data->regenera_costo = $regenera_costo;
        return $data;

    }

     public function transacciona_conyuge(int $inm_ubicacion_id, PDO $link){
        $datos = $this->datos_conyuge(link: $link,inm_ubicacion_id: $inm_ubicacion_id);
        if(errores::$error){
            return $this->error->error(mensaje: 'Error al obtener dato conyuge',data:  $datos);
        }

        if($datos->tiene_dato){
            $result_conyuge = $this->ajusta_conyuge(datos: $datos,inm_ubicacion_id: $inm_ubicacion_id,link: $link);
            if (errores::$error) {
                return $this->error->error(mensaje: 'Error al insertar conyuge', data: $result_conyuge);
            }
            $datos->result_conyuge = $result_conyuge;
        }
        return $datos;
    }

    private function tiene_dato(array $row): bool
    {
        $tiene_dato = false;
        foreach ($row as $value){
            if($value === null){
                $value = '';
            }
            $value = trim($value);
            if($value!==''){
                $tiene_dato = true;
                break;
            }
        }
        return $tiene_dato;
    }

    /**
     * Obtiene las ubicaciones con precio
     * @param string $etapa Etapa de filtro
     * @param int $inm_comprador_id Comprador para obtener precio
     * @param bool $todas Si todas obtiene todas las ubicaciones
     * @return array
     * @version 2.126.0
     */
    final public function ubicaciones_con_precio(string $etapa, int $inm_comprador_id, bool $todas = false): array
    {
        if($inm_comprador_id<=0){
            return $this->error->error(mensaje: 'Error inm_comprador_id debe ser mayor a 0',data: $inm_comprador_id);
        }

        $data = $this->data_ubicaciones(etapa: $etapa,inm_comprador_id:  $inm_comprador_id,todas:  $todas);
        if (errores::$error) {
            return $this->error->error(mensaje: 'Error al obtener data de ubicaciones', data: $data);
        }
        $inm_ubicaciones = $this->asigna_precios(inm_comprador: $data->inm_comprador,
            r_inm_ubicacion:  $data->r_inm_ubicacion);
        if(errores::$error){
            return $this->error->error(mensaje: 'Error al asignar precio de venta inm_ubicaciones',data: $inm_ubicaciones);
        }

        return $inm_ubicaciones;

    }

    /**
     * Valida que la entrada de consulta de precios sea valida
     * @param array|stdClass $inm_comprador Datos de comprador
     * @param array|stdClass $inm_ubicacion Datos de ubicacion
     * @return array|true
     * @version 2.120.0
     */
    private function valida_ids_precio(array|stdClass $inm_comprador, array|stdClass $inm_ubicacion): bool|array
    {
        $keys = array('inm_ubicacion_id');
        $valida = $this->validacion->valida_ids(keys: $keys,registro:  $inm_ubicacion);
        if(errores::$error){
            return $this->error->error(mensaje: 'Error al al validar ubicacion',data: $valida);
        }

        $keys = array('inm_institucion_hipotecaria_id');
        $valida = $this->validacion->valida_ids(keys: $keys,registro:  $inm_comprador);
        if(errores::$error){
            return $this->error->error(mensaje: 'Error al al validar inm_comprador',data: $valida);
        }
        return true;
    }


}